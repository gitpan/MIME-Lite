<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- Generated by pod2coolhtml 1.101
  -- Using Pod::CoolHTML 1.104 , (C) 1997 by Eryq (eryq@enteract.com).
  --
  -- DO NOT EDIT THIS HTML FILE! All your changes will be lost.
  -- Edit the POD or Perl file that was used to create it.
  -->
<HTML>

<HEAD>
<TITLE>MIME::Lite</TITLE>
</HEAD>
<BODY LINK=#C00000 ALINK=#FF2020 VLINK=#900000>
<A NAME="__top"> </A><TABLE WIDTH="100%">

<TR VALIGN="TOP"><TD ALIGN="LEFT"><CENTER>
<H1><FONT SIZE=7 COLOR=#600020><B>MIME::<BR>Lite</B></FONT></H1><IMG SRC="mime-sm.gif" ALT="MIME!">
		<P>
		<FONT SIZE=+1><I>It's MIME time!</I></FONT></CENTER>
<TD>
<UL>
<LI><A HREF="#name">NAME</A>
</LI><LI><A HREF="#synopsis">SYNOPSIS</A>
</LI><LI><A HREF="#description">DESCRIPTION</A>
</LI><LI><A HREF="#more_examples">MORE EXAMPLES</A>
</LI><LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
</LI><UL>
<LI><A HREF="#construction">Construction</A>
</LI><LI><A HREF="#settinggetting_headers_and_attri">Setting/getting headers and attributes</A>
</LI><LI><A HREF="#output">Output</A>
</LI><LI><A HREF="#sending">Sending</A>
</LI></UL>
<LI><A HREF="#notes">NOTES</A>
</LI><UL>
<LI><A HREF="#limitations_of_this_module">Limitations of this module</A>
</LI><LI><A HREF="#cheap_and_easy_mailing">Cheap and easy mailing</A>
</LI><LI><A HREF="#under_the_hood">Under the hood</A>
</LI></UL>
<LI><A HREF="#a_mime_primer">A MIME PRIMER</A>
</LI><UL>
<LI><A HREF="#content_types">Content types</A>
</LI><LI><A HREF="#content_transfer_encodings">Content transfer encodings</A>
</LI></UL>
<LI><A HREF="#change_log">CHANGE LOG</A>
</LI><LI><A HREF="#terms_and_conditions">TERMS AND CONDITIONS</A>
</LI><LI><A HREF="#nutritional_information">NUTRITIONAL INFORMATION</A>
</LI><LI><A HREF="#author">AUTHOR</A>
</LI></UL>

</TABLE>

<P><HR>
<A NAME="name">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NAME</FONT></H1>
</A>


<P>
MIME::Lite - low-calorie MIME generator


<P>
<I><B>WARNING:</B> This is Alpha code.  I have not yet fully tested it, and I can't
guarantee that the interface won't change in the next few releases
in a non-backwards-compatible manner.  It is being provided to the
community for suggestions and in the hopes that it will be useful.</I>


<P><HR>
<A NAME="synopsis">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
SYNOPSIS</FONT></H1>
</A>


<P>
<PRE>    use MIME::Lite;</PRE>



<P>
Create a single-part message:


<P>
<PRE>    # Create a new single-part message, to send a GIF file:
    &#36;msg = new MIME::Lite 
               -From    =&gt;'me@myhost.com',
               -To      =&gt;'you@yourhost.com',
                Cc      =&gt;'some@other.com, some@more.com',
                Subject =&gt;'Helloooooo, nurse!',    
                Type    =&gt;'image/gif',
                Path    =&gt;'hellonurse.gif';</PRE>



<P>
Create a multipart message (i.e., one with attachments):


<P>
<PRE>    # Create a new multipart message:
    &#36;msg = new MIME::Lite 
               -From    =&gt;'me@myhost.com',
               -To      =&gt;'you@yourhost.com',
               -Cc      =&gt;'some@other.com, some@more.com',
               -Subject =&gt;'A message with 2 parts...',
                Type    =&gt;'multipart/mixed';</PRE>



<P>
<PRE>    # Add parts (each &quot;attach&quot; has same arguments as &quot;new&quot;):
    attach &#36;msg 
                Type     =&gt;'TEXT',   
                Data     =&gt;&quot;Here's the GIF file you wanted&quot;;  
    attach &#36;msg 
                Type     =&gt;'image/gif',
                Path     =&gt;'aaa000123.gif',
                Filename =&gt;'logo.gif';</PRE>



<P><HR>
<A NAME="description">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
DESCRIPTION</FONT></H1>
</A>


<P>
In the never-ending quest for great taste with fewer calories,
we proudly present: <I>MIME::Lite</I>.


<P>
MIME::Lite is intended as a simple, standalone module for generating
(not parsing!) MIME messages... specifically, it allows you to
output a simple, decent single- or multi-part message with text or binary
attachments.  It does not require that you have the Mail:: or MIME::
modules installed.


<P>
You can specify each message part as either the literal data itself (in
a scalar or array), or as a string which can be given to open() to get
a readable filehandle (e.g., &quot;&lt;filename&quot; or &quot;somecommand|&quot;).


<P>
If you need more sophisticated behavior, please get the MIME-tools
package instead.  I will be more likely to add stuff to that toolkit
over this one.


<P><HR>
<A NAME="more_examples">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
MORE EXAMPLES</FONT></H1>
</A>


<P>
Create a multipart message exactly as above, but using the 
&quot;attach to singlepart&quot; hack:


<P>
<PRE>    # Create a new multipart message:
    &#36;msg = new MIME::Lite 
               -From    =&gt;'me@myhost.com',
               -To      =&gt;'you@yourhost.com',
                Cc      =&gt;'some@other.com, some@more.com',
                Subject =&gt;'A message with 2 parts...',
                Type    =&gt;'TEXT',
                Data    =&gt;&quot;Here's the GIF file you wanted&quot;;  </PRE>



<P>
<PRE>    # Attach a part:
    attach &#36;msg 
                Type     =&gt;'image/gif',
                Path     =&gt;'aaa000123.gif',
                Filename =&gt;'logo.gif';</PRE>



<P>
Output a message to a filehandle:


<P>
<PRE>    # Write it to a filehandle:
    &#36;msg-&gt;print(\*STDOUT); </PRE>



<P>
<PRE>    # Write just the header:
    &#36;msg-&gt;print_header(\*STDOUT); </PRE>



<P>
<PRE>    # Write just the encoded body:
    &#36;msg-&gt;print_body(\*STDOUT); </PRE>



<P>
Get a message as a string:


<P>
<PRE>    # Get it as a string:
    &#36;str = &#36;msg-&gt;stringify;</PRE>



<P>
<PRE>    # Get just the header:
    &#36;str = &#36;msg-&gt;stringify_header;</PRE>



<P>
<PRE>    # Get just the encoded body:
    &#36;str = &#36;msg-&gt;stringify_body;</PRE>



<P>
# Send a message (Unix systems only!):


<P>
<PRE>    # Send it!
    &#36;msg-&gt;send;</PRE>



<P><HR>
<A NAME="public_interface">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
PUBLIC INTERFACE</FONT></H1>
</A>


<P><HR>
<A NAME="construction">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Construction</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="new">new [PARAMHASH]</A></B><DD>

<I>Class method, constructor.</I>
Create a new message object.


<P>
If any arguments are given, they are passed into build(); otherwise,
just the empty object is created.


<P><DT><B><A NAME="attach">attach [OBJECT|PARAMHASH]</A></B><DD>

<I>Instance method.</I>
Add a new part to this message, and return the new part.


<P>
You can attach a MIME::Lite OBJECT, or have it create one by specifying
a PARAMHASH that will be automatically given to new().


<P>
One of the possibly-quite-useful hacks thrown into this is the 
&quot;attach-to-singlepart&quot; hack: if you attempt to attach a part (let's
call it &quot;part 1&quot;) to a message that <I>isn't</I> a multipart message
(the &quot;self&quot; object in this case), the following happens:

<UL>

<P><LI>A new part (call it &quot;part zero&quot;) is made.


<P><LI>The MIME attributes and data (but <I>not</I> the headers)
are cut from the &quot;self&quot; message, and pasted into &quot;part 0&quot;.


<P><LI>The &quot;self&quot; is turned into a &quot;multipart/mixed&quot; message.


<P><LI>The new &quot;part 0&quot; is added to the &quot;self&quot;, and <I>then</I> &quot;part 1&quot; is added.

</UL>


<P>
One of the nice side-effects is that you can create a text message
and then add zero or more attachments to it; it will be output much
as a user agent like Netscape would output the message.


<P><DT><B><A NAME="build">build [PARAMHASH]</A></B><DD>

<I>Class/instance method, initiallizer.</I>
Create (or initiallize) a MIME message object.  
PARAMHASH can contain the following keys:

<DL>
<P><DT><B><A NAME="fieldname">-FIELDNAME</A></B><DD>

Any field you want placed in the message header.  These fields will be set
<I>after</I> the ones I set, so be careful: don't set any MIME fields like 
<CODE>Content-type</CODE> unless you know what you're doing!


<P><DT><B><A NAME="data">Data</A></B><DD>

<I>Alternative to &quot;Path&quot;.</I>
The actual message data.  This may be a scalar or a ref to an array of
strings; if the latter, the message consists of a simple concatenation 
of all the strings in the array.


<P><DT><B><A NAME="disposition">Disposition</A></B><DD>

<I>Optional.</I>
The content disposition, <CODE>&quot;inline&quot;</CODE> or <CODE>&quot;attachment&quot;</CODE>.
The default is <CODE>&quot;inline&quot;</CODE>.


<P><DT><B><A NAME="encoding">Encoding</A></B><DD>

<I>Optional.</I>
The content transfer encoding.  <B>You are advised to put this in explicitly</B>
if you know it, especially if your mail is 7-bit clean.
The default is <CODE>&quot;binary&quot;</CODE>.


<P><DT><B><A NAME="filename">Filename</A></B><DD>

<I>Optional.</I>
The name of the attachment.  You can use this to supply a filename
if the one in the Path is inadequate, or if you're using the Data argument.


<P><DT><B><A NAME="length">Length</A></B><DD>

<I>Optional.</I>
Set the content length explicitly.  Normally, this header is automatically
computed, but only under certain circumstances (see <A HREF="#limitations">&quot;Limitations&quot;</A>).


<P><DT><B><A NAME="path">Path</A></B><DD>

<I>Alternative to &quot;Data&quot;.</I>
Path to a file containing the data... actually, it can be any open()able
expression.  If it looks like a path, the last element will automatically 
be treated as the filename.  Ignored if &quot;Data&quot; is present.
See &quot;ReadNow&quot; also.


<P><DT><B><A NAME="readnow">ReadNow</A></B><DD>

<I>Optional, for use with &quot;Path&quot;.</I>
If true, will open the path and slurp the contents into core now.
This is useful if the Path points to a command and you don't want 
to run the command over and over if outputting the message several
times.  <B>Fatal exception</B> raised if the open fails.


<P><DT><B><A NAME="top">Top</A></B><DD>

<I>Optional.</I>
If defined, indicates whether or not this is a &quot;top-level&quot; MIME message.
Parts of a multipart message are <I>not</I> top-level.
Default is true.


<P><DT><B><A NAME="type">Type</A></B><DD>

<I>Optional.</I>
The MIME content type, or one of these special values (case-sensitive):


<P>
<PRE>     &quot;TEXT&quot;   means &quot;text/plain&quot;
     &quot;BINARY&quot; means &quot;application/octet-stream&quot;</PRE>



<P>
The default is <CODE>&quot;TEXT&quot;</CODE>.

</DL>

<P>
A picture being worth 1000 words (which
is of course 2000 bytes, so it's probably more of an &quot;icon&quot; than a &quot;picture&quot;,
but I digress...), here are some examples:


<P>
<PRE>    &#36;msg = build MIME::Lite 
              -From     =&gt; 'yelling@inter.com',
              -To       =&gt; 'stocking@fish.net',
              -Subject  =&gt; &quot;Hi there!&quot;,
               Type     =&gt; 'TEXT',
               Encoding =&gt; '7bit',
               Data     =&gt; &quot;Just a quick note to say hi!&quot;;</PRE>



<P>
<PRE>    &#36;msg = build MIME::Lite 
              -From     =&gt; 'dorothy@emerald-city.oz',
              -To       =&gt; 'gesundheit@edu.edu.edu',
              -Subject  =&gt; &quot;A gif for U&quot;
               Type     =&gt; 'image/gif',
               Path     =&gt; &quot;/home/httpd/logo.gif&quot;;</PRE>



<P>
<PRE>    &#36;msg = build MIME::Lite 
              -From     =&gt; 'laughing@all.of.us',
              -To       =&gt; 'scarlett@fiddle.dee.de',
              -Subject  =&gt; &quot;A gzipp'ed tar file&quot;,
               Type     =&gt; 'x-gzip',
               Path     =&gt; &quot;gzip &lt; /usr/inc/somefile.tar |&quot;,
               ReadNow  =&gt; 1,
               File     =&gt; &quot;somefile.tgz&quot;;</PRE>



<P>
To show you what's really going on, that last example could also 
have been written:


<P>
<PRE>    &#36;msg = new MIME::Lite;</PRE>



<P>
<PRE>    &#36;msg-&gt;build(Type    =&gt; 'x-gzip',
                Path    =&gt; &quot;gzip &lt; /usr/inc/somefile.tar |&quot;,
                ReadNow =&gt; 1,
                File    =&gt; &quot;somefile.tgz&quot;);</PRE>



<P>
<PRE>    &#36;msg-&gt;add(From    =&gt; &quot;laughing@all.of.us&quot;);
    &#36;msg-&gt;add(To      =&gt; &quot;scarlett@fiddle.dee.de&quot;);
    &#36;msg-&gt;add(Subject =&gt; &quot;A gzipp'ed tar file&quot;);  </PRE>



<P><DT><B><A NAME="sign">sign PARAMHASH</A></B><DD>

Sign the message.  This forces the message to be read into core,
after which the signature is appended to it.

<DL>
<P><DT><B><A NAME="data">Data</A></B><DD>

As in <A HREF="#build">build()</A>: the literal signature data.
Can be either a scalar or a ref to an array of scalars.


<P><DT><B><A NAME="path">Path</A></B><DD>

As in <A HREF="#build">build()</A>: the path to the file.

</DL>

<P>
If no arguments are given, the default is:


<P>
<PRE>    Path =&gt; &quot;&#36;ENV{HOME}/.signature&quot;</PRE>


</DL>

<P>
The content-length is recomputed.


<P><HR>
<A NAME="settinggetting_headers_and_attri">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Setting/getting headers and attributes</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="add">add TAG,VALUE</A></B><DD>

Add field TAG with the given VALUE to the end of the header. 
The TAG will be converted to all-lowercase, and the VALUE 
will be made &quot;safe&quot; (returns will be given a trailing space).


<P>
Normally, you will use this to add non-MIME tags:


<P>
<PRE>    &#36;msg-&gt;add(&quot;Subject&quot; =&gt; &quot;Hi there!&quot;);</PRE>



<P>
Giving VALUE an arrayref will cause all those values to be added:


<P>
<PRE>    &#36;msg-&gt;add(&quot;Received&quot; =&gt; [&quot;here&quot;, &quot;there&quot;, &quot;everywhere&quot;]</PRE>



<P>
<I>Note:</I> add() is probably going to be more efficient than <A HREF="#replace">replace()</A>,
so you're better off using it for most applications.


<P>
<I>Note:</I> the name comes from Mail::Header.


<P><DT><B><A NAME="attr">attr ATTR,[VALUE]</A></B><DD>

Set MIME attribute ATTR to the string VALUE.  
ATTR is converted to all-lowercase.
This method is normally used to set/get MIME attributes:


<P>
<PRE>    &#36;msg-&gt;attr(&quot;content-type&quot;         =&gt; &quot;text/html&quot;);
    &#36;msg-&gt;attr(&quot;content-type.charset&quot; =&gt; &quot;US-ASCII&quot;);
    &#36;msg-&gt;attr(&quot;content-type.name&quot;    =&gt; &quot;homepage.html&quot;);</PRE>



<P>
This would cause the final output to look something like this:


<P>
<PRE>    Content-type: text/html; charset=US-ASCII; name=&quot;homepage.html&quot;</PRE>



<P>
Note that the special empty sub-field tag indicates the anonymous 
first sub-field.


<P>
Giving VALUE as undefined will cause the contents of the named
subfield to be deleted.


<P>
Supplying no VALUE argument just returns the attribute's value:


<P>
<PRE>    &#36;type = &#36;msg-&gt;attr(&quot;content-type&quot;);        # returns &quot;text/html&quot;
    &#36;name = &#36;msg-&gt;attr(&quot;content-type.name&quot;);   # returns &quot;homepage.html&quot;</PRE>



<P><DT><B><A NAME="data">data [DATA]</A></B><DD>

Get/set the literal DATA of the message.  The DATA may be
either a scalar, or a reference to an array of scalars (which
will simply be joined).


<P>
<I>Warning:</I> setting the data causes the &quot;content-length&quot; attribute
to be recomputed (possibly to nothing).


<P><DT><B><A NAME="delete">delete TAG</A></B><DD>

Delete field TAG with the given VALUE to the end of the header.  
The TAG will be converted to all-lowercase.


<P>
<PRE>    &#36;msg-&gt;delete(&quot;Subject&quot;);</PRE>



<P>
<I>Note:</I> the name comes from Mail::Header.


<P><DT><B><A NAME="fields">fields</A></B><DD>

Return the full header for the object, as a ref to an array
of <CODE>[TAG, VALUE]</CODE> pairs.


<P>
Any fields that the user has explicitly set will override the
corresponding MIME fields that we would generate.  So: <I>don't</I> say:


<P>
<PRE>    &#36;msg-&gt;set(&quot;Content-type&quot; =&gt; &quot;text/html; charset=US-ASCII&quot;);</PRE>



<P>
unless you <I>mean it</I>!


<P>
<I>Note:</I> I called this &quot;fields&quot; because the header() method of
Mail::Header returns something different, but similar enough to 
be confusing.


<P><DT><B><A NAME="filename">filename [FILENAME]</A></B><DD>

Set the filename which this data will be reported as.
This actually sets both &quot;standard&quot; attributes.


<P>
With no argument, returns the filename as dictated by the 
content-disposition.


<P><DT><B><A NAME="get_length">get_length [VALUE]</A></B><DD>

Recompute (and return) the content length for the message.


<P>
<PRE>    &#36;msg-&gt;get_length;</PRE>



<P>
Returns the length, or undefined if not set.


<P>
The content length is only set to a defined value if the message
is a singlepart with binary encoding, and if the body is available
either in-core or as a simple file.


<P><DT><B><A NAME="path">path [PATH]</A></B><DD>

Get/set the literal DATA of the message.


<P>
<I>Warning:</I> setting the path recomputes any existing &quot;content-length&quot; field,
and re-sets the &quot;filename&quot; (to the last element of the path if it
looks like a simple path, and to nothing if not).


<P><DT><B><A NAME="replace">replace TAG,VALUE</A></B><DD>

Delete all occurences of fields named TAG, and add a new
field with the given VALUE.  TAG is converted to all-lowercase.
Normally, you will use this to set non-MIME tags:


<P>
<PRE>    &#36;msg-&gt;replace(&quot;Subject&quot; =&gt; &quot;Hi there!&quot;);</PRE>



<P>
Giving VALUE as undefined will simply cause the contents of the named
field to be deleted.  Giving VALUE as an arrayref will cause all the values
in the array to be added.


<P>
<I>Note:</I> the name comes from Mail::Header.

</DL>

<P><HR>
<A NAME="output">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Output</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="print">print [OUTHANDLE]</A></B><DD>

<I>Instance method.</I> 
Print the message to the given output handle, or to the currently-selected
filehandle if none was given.


<P>
All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.


<P><DT><B><A NAME="print_body">print_body [OUTHANDLE]</A></B><DD>

<I>Instance method.</I> 
Print the body of the message to the given output handle, 
or to the currently-selected filehandle if none was given.


<P>
All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.


<P>
<B>Fatal exception</B> raised if unable to open any of the input files,
or if a part contains no data, or if an unsupported encoding is 
encountered.


<P><DT><B><A NAME="print_header">print_header [OUTHANDLE]</A></B><DD>

<I>Instance method.</I> 
Print the header of the message to the given output handle, 
or to the currently-selected filehandle if none was given.


<P>
All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.


<P><DT><B><A NAME="stringify">stringify</A></B><DD>

<I>Instance method.</I> 
Return the entire message as a string.


<P><DT><B><A NAME="stringify_body">stringify_body</A></B><DD>

<I>Instance method.</I> 
Return the encoded body as a string.


<P>
<I>Note:</I> uses <A HREF="#print_body">print_body()</A> internally to print to a scalar.


<P><DT><B><A NAME="stringify_header">stringify_header</A></B><DD>

<I>Instance method.</I> 
Return the header as a string.

</DL>

<P><HR>
<A NAME="sending">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Sending</FONT></H2>
</A>

<DL>
<P><DT><B><A NAME="send">send</A></B><DD>

<I>Instance method.</I>  
Sends the message.


<P>
Right now, this is done by piping it into the &quot;sendmail&quot; command
as given by <A HREF="#sendmail">sendmail()</A>.  It probably will only work on Unix systems.


<P>
Returns false if sendmail <I>seems</I> to have failed, true otherwise.
<B>Fatal exception</B> raised if the open fails.


<P><DT><B><A NAME="sendmail">sendmail COMMAND...</A></B><DD>

<I>Class method.</I>  
Set up the &quot;sendmail&quot; command used by <A HREF="#send">send()</A>.
You may supply it as either a single string, or an array of 
path-to-command-plus-arguments:


<P>
<PRE>    sendmail MIME::Lite &quot;/usr/lib/sendmail&quot;, &quot;-t&quot;, &quot;-oi&quot;, &quot;-oem&quot;;</PRE>



<P>
What you see above is the default.

</DL>

<P><HR>
<A NAME="notes">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NOTES</FONT></H1>
</A>


<P><HR>
<A NAME="limitations_of_this_module">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Limitations of this module</FONT></H2>
</A>


<P>
This is &quot;lite&quot;, after all...

<UL>

<P><LI>There's no parsing.  Get MIME-tools if you need to parse MIME messages.


<P><LI>MIME::Lite messages are currently <I>not</I> interchangeable with 
either Mail::Internet or MIME::Entity objects.  This is a completely 
separate module.


<P><LI>A content-length field is only inserted if the encoding is binary,
the message is a singlepart, and all the document data is available
at build() time by virtue of residing in a simple path, or in-core.
Since content-length is not a standard MIME field anyway (that's right, kids:
it's not in the MIME RFCs, it's an HTTP thing), this seems pretty fair.


<P><LI>MIME::Lite alone cannot help you lose weight.  You must supplement
your use of MIME::Lite with a healthy diet and exercise.

</UL>


<P><HR>
<A NAME="cheap_and_easy_mailing">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Cheap and easy mailing</FONT></H2>
</A>


<P>
I thought putting in a sendmail invocation wasn't too bad an idea,
since a lot of Perlers are on UNIX systems.  The default arguments
to sendmail (which you can change) are:


<P>
<PRE>     -t      Scan message for To:, Cc:, Bcc:, etc.</PRE>



<P>
<PRE>     -oi     Do NOT treat a single &quot;.&quot; on a line as a message terminator.
             As in, &quot;-oi vey, it truncated my message... why?!&quot;</PRE>



<P>
<PRE>     -oem    On error, mail back the message (I assume to the
             appropriate address, given in the header).
             When mail returns, circle is complete.  Jai guru deva -oem.</PRE>



<P><HR>
<A NAME="under_the_hood">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Under the hood</FONT></H2>
</A>


<P>
This class treats a MIME header in the most abstract sense,
as being a collection of high-level attributes.  The actual
RFC-822-style header fields are not constructed until it's time
to actually print the darn thing.


<P><HR>
<A NAME="a_mime_primer">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
A MIME PRIMER</FONT></H1>
</A>


<P><HR>
<A NAME="content_types">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Content types</FONT></H2>
</A>


<P>
The &quot;Type&quot; parameter of <A HREF="#build">build()</A> is a <I>content type</I>. 
This is the actual type of data you are sending.  
Generally this is a string of the form <CODE>&quot;majortype/minortype&quot;</CODE>.


<P>
Here are the major MIME types.
A more-comprehensive listing may be found in RFC-2046.

<DL>
<P><DT><B><A NAME="application">application</A></B><DD>

Data which does not fit in any of the other categories, particularly 
data to be processed by some type of application program. 
<CODE>application/octet-stream</CODE>, <CODE>application/gzip</CODE>, <CODE>application/postscript</CODE>...


<P><DT><B><A NAME="audio">audio</A></B><DD>

Audio data.
<CODE>audio/basic</CODE>...


<P><DT><B><A NAME="image">image</A></B><DD>

Graphics data.
<CODE>image/gif</CODE>, <CODE>image/jpeg</CODE>...


<P><DT><B><A NAME="message">message</A></B><DD>

A message, usually another mail or MIME message.
<CODE>message/rfc822</CODE>...


<P><DT><B><A NAME="multipart">multipart</A></B><DD>

A message containing other messages.
<CODE>multipart/mixed</CODE>, <CODE>multipart/alternative</CODE>...


<P><DT><B><A NAME="text">text</A></B><DD>

Textual data, meant for humans to read.
<CODE>text/plain</CODE>, <CODE>text/html</CODE>...


<P><DT><B><A NAME="video">video</A></B><DD>

Video or video+audio data.
<CODE>video/mpeg</CODE>...

</DL>

<P><HR>
<A NAME="content_transfer_encodings">
<H2><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h2bullet.gif" ALT="" BORDER="0"></A>
Content transfer encodings</FONT></H2>
</A>


<P>
The &quot;Encoding&quot; parameter of <A HREF="#build">build()</A>.
This is how the message body is packaged up for safe transit.


<P>
Here are the 5 major MIME encodings.
A more-comprehensive listing may be found in RFC-2045.

<DL>
<P><DT><B><A NAME="7bit">7bit</A></B><DD>

Basically, no encoding is done.  However, this label guarantees that no
8-bit characters are present, and that lines do not exceed 1000 characters 
in length.


<P><DT><B><A NAME="8bit">8bit</A></B><DD>

Basically, no encoding is done.  The message might contain 8-bit characters,
but this label guarantees that lines do not exceed 1000 characters in length.


<P><DT><B><A NAME="binary">binary</A></B><DD>

Basically, no encoding is done.  Message might contain 8-bit characters,
and lines might be longer than 1000 characters long.


<P>
The most liberal, and the least likely to get through mail gateways.  
Use sparingly.


<P><DT><B><A NAME="base64">base64</A></B><DD>

Like &quot;uuencode&quot;, but very well-defined.  This is how you should send
essentially binary information (tar files, GIFs, JPEGs, etc.).


<P><DT><B><A NAME="quoted">quoted-printable</A></B><DD>

Useful for encoding messages which are textual in nature, yet which contain 
non-ASCII characters (e.g., Latin-1, Latin-2, or any other 8-bit alphabet).

</DL>

<P><HR>
<A NAME="change_log">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
CHANGE LOG</FONT></H1>
</A>

<DL>
<P><DT><B><A NAME="version">Version 1.102</A></B><DD>

Initial release.


<P><DT><B><A NAME="version">Version 1.101</A></B><DD>

Baseline code.

</DL>

<P><HR>
<A NAME="terms_and_conditions">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
TERMS AND CONDITIONS</FONT></H1>
</A>


<P>
Copyright (c) 1997 by Eryq.  All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.


<P>
This software comes with <B>NO WARRANTY</B> of any kind.
See the COPYING file in the distribution for details.


<P><HR>
<A NAME="nutritional_information">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
NUTRITIONAL INFORMATION</FONT></H1>
</A>


<P>
For some reason, the US FDA says that this is now required by law
on any products that bear the name &quot;Lite&quot;...


<P>
<PRE>    Serving size:             1 module
    Servings per container:   1
    Calories:                 0
    Fat:                      0g
      Saturated Fat:          0g</PRE>



<P>
<PRE>    Warning: for consumption by hardware only!  May produce 
    indigestion in humans if taken internally.</PRE>



<P><HR>
<A NAME="author">
<H1><FONT COLOR=#600020>
<A HREF="#__top"><IMG SRC="h1bullet.gif" ALT="" BORDER="0"></A>
AUTHOR</FONT></H1>
</A>


<P>
Eryq, (who really should be wrapping holiday presents instead).
<I><A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A></I> / <I><A HREF="http://enteract.com/~eryq">http://enteract.com/~eryq</A></I>.


<P>
Created: 11 December 1996.  Ho ho ho.


<P><HR>
<SMALL>
		Last updated: Sat Mar  1 04:11:36 1997 <BR>
		Generated by pod2coolhtml 1.101.  Want a copy?  Just email
		<A HREF="mailto:eryq@enteract.com">eryq@enteract.com</A>.
		(Yes, it's free.)
		</SMALL></BODY>
</HTML>
