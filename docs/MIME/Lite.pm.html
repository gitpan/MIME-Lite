<HTML>
<HEAD>
  <TITLE>MIME::Lite</TITLE>
</HEAD>
<BODY 
       bgcolor="#FFFFFF" link="#BE1B58" vlink="#8C337C" alink="#F28EAA">
<A HREF="http://www.zeegee.com" TARGET="_top"><IMG SRC="icons/zeegee.gif" ALT="ZeeGee Software" ALIGN="RIGHT" BORDER="0"></A><A NAME="__TOP__"><H1>MIME::Lite</H1>
</A><UL>
<LI> <A HREF="#NAME">NAME</A>
<LI> <A HREF="#SYNOPSIS">SYNOPSIS</A>
<LI> <A HREF="#DESCRIPTION">DESCRIPTION</A>
<LI> <A HREF="#MORE_EXAMPLES">MORE EXAMPLES</A>
<UL>
<LI> <A HREF="#Attach_a_GIF_to_a_text_message">Attach a GIF to a text message</A>
<LI> <A HREF="#Send_an_HTML_document_with_images_included">Send an HTML document... with images included!</A>
<LI> <A HREF="#Output_a_message_to_a_filehandle">Output a message to a filehandle</A>
<LI> <A HREF="#Get_a_message_as_a_string">Get a message as a string</A>
<LI> <A HREF="#Change_how_messages_are_sent">Change how messages are sent</A>
</UL>
<LI> <A HREF="#PUBLIC_INTERFACE">PUBLIC INTERFACE</A>
<UL>
<LI> <A HREF="#Construction">Construction</A>
<LI> <A HREF="#Setting_getting_headers_and_attributes">Setting/getting headers and attributes</A>
<LI> <A HREF="#Setting_getting_message_data">Setting/getting message data</A>
<LI> <A HREF="#Output">Output</A>
<LI> <A HREF="#Sending">Sending</A>
<LI> <A HREF="#Miscellaneous">Miscellaneous</A>
</UL>
<LI> <A HREF="#NOTES">NOTES</A>
<UL>
<LI> <A HREF="#Limitations">Limitations</A>
<LI> <A HREF="#Cheap_and_easy_mailing">Cheap and easy mailing</A>
<LI> <A HREF="#Under_the_hood">Under the hood</A>
</UL>
<LI> <A HREF="#WARNINGS">WARNINGS</A>
<UL>
<LI> <A HREF="#MIME-_and_non-MIME_header_fields">MIME- and non-MIME header fields</A>
<LI> <A HREF="#Lines_consisting_of_a_single_dot">Lines consisting of a single dot</A>
</UL>
<LI> <A HREF="#A_MIME_PRIMER">A MIME PRIMER</A>
<UL>
<LI> <A HREF="#Content_types">Content types</A>
<LI> <A HREF="#Content_transfer_encodings">Content transfer encodings</A>
</UL>
<LI> <A HREF="#CHANGE_LOG">CHANGE LOG</A>
<LI> <A HREF="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</A>
<LI> <A HREF="#NUTRITIONAL_INFORMATION">NUTRITIONAL INFORMATION</A>
<LI> <A HREF="#AUTHOR">AUTHOR</A>
</UL>
</A>

<P><HR>
<A NAME="NAME"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NAME</H2></A>


<P>MIME::Lite - low-calorie MIME generator



<P><HR>
<A NAME="SYNOPSIS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> SYNOPSIS</H2></A>

<PRE>
    use MIME::Lite;
   
Create a single-part message:
</PRE>
<PRE>
    ### Create a new single-part message, to send a GIF file:
    $msg = MIME::Lite-&gt;new(
                 From     =&gt;'me@myhost.com',
                 To       =&gt;'you@yourhost.com',
                 Cc       =&gt;'some@other.com, some@more.com',
                 Subject  =&gt;'Helloooooo, nurse!',
                 Type     =&gt;'image/gif',
                 Encoding =&gt;'base64',
                 Path     =&gt;'hellonurse.gif'
		 );
</PRE>

<P>Create a multipart message (i.e., one with attachments):

<PRE>
    ### Create a new multipart message:
    $msg = MIME::Lite-&gt;new( 
                 From    =&gt;'me@myhost.com',
                 To      =&gt;'you@yourhost.com',
                 Cc      =&gt;'some@other.com, some@more.com',
                 Subject =&gt;'A message with 2 parts...',
                 Type    =&gt;'multipart/mixed'
		 );
    
    ### Add parts (each &quot;attach&quot; has same arguments as &quot;new&quot;):
    $msg-&gt;attach(Type     =&gt;'TEXT',   
                 Data     =&gt;&quot;Here's the GIF file you wanted&quot;
		 );  
    $msg-&gt;attach(Type     =&gt;'image/gif',
                 Path     =&gt;'aaa000123.gif',
                 Filename =&gt;'logo.gif'
		 );
</PRE>

<P>Output a message:

<PRE>
    # Format as a string:
    $str = $msg-&gt;as_string;
    
    # Print to a filehandle (say, a &quot;sendmail&quot; stream):
    $msg-&gt;print(\*SENDMAIL);
</PRE>

<P>Send a message:

<PRE>
    # Send in the &quot;best&quot; way (the default is to use &quot;sendmail&quot;):
    $msg-&gt;send;
      
</PRE>


<P><HR>
<A NAME="DESCRIPTION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> DESCRIPTION</H2></A>


<P>In the never-ending quest for great taste with fewer calories,
we proudly present: <I>MIME::Lite</I>.  


<P>MIME::Lite is intended as a simple, standalone module for generating
(not parsing!) MIME messages... specifically, it allows you to
output a simple, decent single- or multi-part message with text or binary
attachments.  It does not require that you have the Mail:: or MIME::
modules installed.


<P>You can specify each message part as either the literal data itself (in
a scalar or array), or as a string which can be given to open() to get
a readable filehandle (e.g., &quot;&lt;filename&quot; or &quot;somecommand|&quot;).


<P>You don't need to worry about encoding your message data:
this module will do that for you.  It handles the 5 standard MIME encodings.


<P>If you need more sophisticated behavior, please get the MIME-tools
package instead.  I will be more likely to add stuff to that toolkit
over this one.



<P><HR>
<A NAME="MORE_EXAMPLES"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> MORE EXAMPLES</H2></A>



<P><HR>
<A NAME="Attach_a_GIF_to_a_text_message"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Attach a GIF to a text message</H3></A>


<P>This will create a multipart message exactly as above, but using the 
&quot;attach to singlepart&quot; hack:

<PRE>
    ### Create a new multipart message:
    $msg = MIME::Lite-&gt;new(
                 From    =&gt;'me@myhost.com',
                 To      =&gt;'you@yourhost.com',
                 Cc      =&gt;'some@other.com, some@more.com',
                 Subject =&gt;'A message with 2 parts...',
                 Type    =&gt;'TEXT',
                 Data    =&gt;&quot;Here's the GIF file you wanted&quot;
                 );  
    
    ### Attach a part:
    $msg-&gt;attach(Type     =&gt;'image/gif',
                 Path     =&gt;'aaa000123.gif',
                 Filename =&gt;'logo.gif'
                 );
</PRE>


<P><HR>
<A NAME="Send_an_HTML_document_with_images_included"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Send an HTML document... with images included!</H3></A>

<PRE>
    $msg = MIME::Lite-&gt;new(
                 To      =&gt;'you@yourhost.com',
                 Subject =&gt;'HTML with in-line images!',
                 Type    =&gt;'multipart/related'
                 );
    $msg-&gt;attach(Type =&gt; 'text/html',
                 Data =&gt; qq{ &lt;body&gt;
                             Here's &lt;i&gt;my&lt;/i&gt; image: 
                             &lt;img src=&quot;cid:myimage.gif&quot;&gt; 
                             &lt;/body&gt; }
                 );
    $msg-&gt;attach(Type =&gt; 'image/gif',
                 Id   =&gt; 'myimage.gif',
                 Path =&gt; '/path/to/somefile.gif',
                 );
    $msg-&gt;send();
</PRE>


<P><HR>
<A NAME="Output_a_message_to_a_filehandle"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Output a message to a filehandle</H3></A>

<PRE>
    ### Write it to a filehandle:
    $msg-&gt;print(\*STDOUT); 
     
    ### Write just the header:
    $msg-&gt;print_header(\*STDOUT); 
     
    ### Write just the encoded body:
    $msg-&gt;print_body(\*STDOUT); 
</PRE>


<P><HR>
<A NAME="Get_a_message_as_a_string"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Get a message as a string</H3></A>

<PRE>
    ### Get entire message as a string:
    $str = $msg-&gt;as_string;
     
    ### Get just the header:
    $str = $msg-&gt;header_as_string;
     
    ### Get just the encoded body:
    $str = $msg-&gt;body_as_string;
</PRE>


<P><HR>
<A NAME="Change_how_messages_are_sent"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Change how messages are sent</H3></A>

<PRE>
    ### Do something like this in your 'main':
    if ($I_DONT_HAVE_SENDMAIL) {
       MIME::Lite-&gt;send('smtp', &quot;smtp.myisp.net&quot;, Timeout=&gt;60);
    }
     
    ### Now this will do the right thing:
    $msg-&gt;send;         ### will now use Net::SMTP as shown above
</PRE>


<P><HR>
<A NAME="PUBLIC_INTERFACE"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> PUBLIC INTERFACE</H2></A>



<P><HR>
<A NAME="Construction"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Construction</H3></A>



<DL>
<P><DT><B><A NAME="item:new_PARAMHASH">new [PARAMHASH]</A></B></DT>
<DD>
<I>Class method, constructor.</I>
Create a new message object.  


<P>If any arguments are given, they are passed into <CODE>build()</CODE>; otherwise,
just the empty object is created.

<P><DT><B><A NAME="item:attach_OBJECT_PARAMHASH">attach [OBJECT|PARAMHASH]</A></B></DT>
<DD>
<I>Instance method.</I>
Add a new part to this message, and return the new part.


<P>You can attach a MIME::Lite OBJECT, or have it create one by specifying
a PARAMHASH that will be automatically given to <CODE>new()</CODE>.


<P>One of the possibly-quite-useful hacks thrown into this is the 
&quot;attach-to-singlepart&quot; hack: if you attempt to attach a part (let's
call it &quot;part 1&quot;) to a message that <I>isn't</I> a multipart message
(the &quot;self&quot; object in this case), the following happens:



<UL>
<P><LI>
<P>A new part (call it &quot;part 0&quot;) is made.

<P><LI>
<P>The MIME attributes and data (but <I>not</I> the other headers)
are cut from the &quot;self&quot; message, and pasted into &quot;part 0&quot;.

<P><LI>
<P>The &quot;self&quot; is turned into a &quot;multipart/mixed&quot; message.

<P><LI>
<P>The new &quot;part 0&quot; is added to the &quot;self&quot;, and <I>then</I> &quot;part 1&quot; is added.

</UL>


<P>One of the nice side-effects is that you can create a text message
and then add zero or more attachments to it, much in the same way
that a user agent like Netscape allows you to do.

<P><DT><B><A NAME="item:build_PARAMHASH">build [PARAMHASH]</A></B></DT>
<DD>
<I>Class/instance method, initiallizer.</I>
Create (or initiallize) a MIME message object.  
Normally, you'll use the following keys in PARAMHASH:

<PRE>
   * Data, FH, or Path      (either one of these, or none if multipart)
   * Type                   (e.g., &quot;image/jpeg&quot;)
   * From, To, and Subject  (if this is the &quot;top level&quot; of a message)
</PRE>

<P>The PARAMHASH can contain the following keys:



<DL>
<P><DT><B><A NAME="item:fieldname">(fieldname)</A></B></DT>
<DD>
Any field you want placed in the message header, taken from the
standard list of header fields (you don't need to worry about case):

<PRE>
    Bcc           Encrypted     Received      Sender         
    Cc            From          References    Subject 
    Comments	  Keywords      Reply-To      To 
    Content-*	  Message-ID    Resent-*      X-*
    Date          MIME-Version  Return-Path   
                  Organization
</PRE>

<P>To give experienced users some veto power, these fields will be set 
<I>after</I> the ones I set... so be careful: <I>don't set any MIME fields</I>
(like <CODE>Content-type</CODE>) unless you know what you're doing!


<P>To specify a fieldname that's <I>not</I> in the above list, even one that's
identical to an option below, just give it with a trailing <CODE>&quot;:&quot;</CODE>,
like <CODE>&quot;My-field:&quot;</CODE>.  When in doubt, that <I>always</I> signals a mail 
field (and it sort of looks like one too).

<P><DT><B><A NAME="item:Data">Data</A></B></DT>
<DD>
<I>Alternative to &quot;Path&quot; or &quot;FH&quot;.</I>
The actual message data.  This may be a scalar or a ref to an array of
strings; if the latter, the message consists of a simple concatenation 
of all the strings in the array.

<P><DT><B><A NAME="item:Disposition">Disposition</A></B></DT>
<DD>
<I>Optional.</I>
The content disposition, <CODE>&quot;inline&quot;</CODE> or <CODE>&quot;attachment&quot;</CODE>.
The default is <CODE>&quot;inline&quot;</CODE>.

<P><DT><B><A NAME="item:Encoding">Encoding</A></B></DT>
<DD>
<I>Optional.</I>
The content transfer encoding that should be used to encode your data:

<PRE>
   Use encoding:     If your message contains:
   ------------------------------------------------------------
   7bit              Only 7-bit text, all lines &lt;1000 characters
   8bit              8-bit text, all lines &lt;1000 characters
   quoted-printable  8-bit text or long lines (MUCH more reliable than &quot;8bit&quot;)
   base64            Largely non-textual data: a GIF, a tar file, etc.
</PRE>

<P>The default is taken from the Type; generally it is &quot;binary&quot; (no
encoding) for text/*, message/*, and multipart/*, and &quot;base64&quot; for
everything else.  A value of <CODE>&quot;binary&quot;</CODE> is generally <I>not</I> suitable
for sending anything but ASCII text files with lines under 1000
characters, so consider using one of the other values instead.


<P>In the case of &quot;7bit&quot;/&quot;8bit&quot;, long lines are automatically chopped to
legal length; in the case of &quot;7bit&quot;, all 8-bit characters are
automatically <I>removed</I>.  This may not be what you want, so pick your
encoding well!  There's a <A HREF="#A_MIME_PRIMER">A MIME PRIMER</A> in this document with
more info.

<P><DT><B><A NAME="item:FH">FH</A></B></DT>
<DD>
<I>Alternative to &quot;Data&quot; or &quot;Path&quot;.</I>
Filehandle containing the data, opened for reading.
See &quot;ReadNow&quot; also.

<P><DT><B><A NAME="item:Filename">Filename</A></B></DT>
<DD>
<I>Optional.</I>
The name of the attachment.  You can use this to supply a filename
if the one in the Path is inadequate, or if you're using the Data argument.


<P>=item Id
<I>Optional.</I>
Same as setting &quot;content-id&quot;.

<P><DT><B><A NAME="item:Length">Length</A></B></DT>
<DD>
<I>Optional.</I>
Set the content length explicitly.  Normally, this header is automatically
computed, but only under certain circumstances (see <A HREF="#Limitations">Limitations</A>).

<P><DT><B><A NAME="item:Path">Path</A></B></DT>
<DD>
<I>Alternative to &quot;Data&quot; or &quot;FH&quot;.</I>
Path to a file containing the data... actually, it can be any open()able
expression.  If it looks like a path, the last element will automatically 
be treated as the filename. 
See &quot;ReadNow&quot; also.

<P><DT><B><A NAME="item:ReadNow">ReadNow</A></B></DT>
<DD>
<I>Optional, for use with &quot;Path&quot;.</I>
If true, will open the path and slurp the contents into core now.
This is useful if the Path points to a command and you don't want 
to run the command over and over if outputting the message several
times.  <B>Fatal exception</B> raised if the open fails.

<P><DT><B><A NAME="item:Top">Top</A></B></DT>
<DD>
<I>Optional.</I>
If defined, indicates whether or not this is a &quot;top-level&quot; MIME message.
The parts of a multipart message are <I>not</I> top-level.
Default is true.

<P><DT><B><A NAME="item:Type">Type</A></B></DT>
<DD>
<I>Optional.</I>
The MIME content type, or one of these special values (case-sensitive):

<PRE>
     &quot;TEXT&quot;   means &quot;text/plain&quot;
     &quot;BINARY&quot; means &quot;application/octet-stream&quot;
</PRE>

<P>The default is <CODE>&quot;TEXT&quot;</CODE>.

</DL>


<P>A picture being worth 1000 words (which
is of course 2000 bytes, so it's probably more of an &quot;icon&quot; than a &quot;picture&quot;,
but I digress...), here are some examples:

<PRE>
    $msg = build MIME::Lite 
               From     =&gt; 'yelling@inter.com',
               To       =&gt; 'stocking@fish.net',
               Subject  =&gt; &quot;Hi there!&quot;,
               Type     =&gt; 'TEXT',
               Encoding =&gt; '7bit',
               Data     =&gt; &quot;Just a quick note to say hi!&quot;;
 
    $msg = build MIME::Lite 
               From     =&gt; 'dorothy@emerald-city.oz',
               To       =&gt; 'gesundheit@edu.edu.edu',
               Subject  =&gt; &quot;A gif for U&quot;
               Type     =&gt; 'image/gif',
               Path     =&gt; &quot;/home/httpd/logo.gif&quot;;
 
    $msg = build MIME::Lite 
               From     =&gt; 'laughing@all.of.us',
               To       =&gt; 'scarlett@fiddle.dee.de',
               Subject  =&gt; &quot;A gzipp'ed tar file&quot;,
               Type     =&gt; 'x-gzip',
               Path     =&gt; &quot;gzip &lt; /usr/inc/somefile.tar |&quot;,
               ReadNow  =&gt; 1,
               Filename =&gt; &quot;somefile.tgz&quot;;
</PRE>

<P>To show you what's really going on, that last example could also 
have been written:

<PRE>
    $msg = new MIME::Lite;
    
    $msg-&gt;build(Type     =&gt; 'x-gzip',
                Path     =&gt; &quot;gzip &lt; /usr/inc/somefile.tar |&quot;,
                ReadNow  =&gt; 1,
                Filename =&gt; &quot;somefile.tgz&quot;);    
    $msg-&gt;add(From    =&gt; &quot;laughing@all.of.us&quot;);
    $msg-&gt;add(To      =&gt; &quot;scarlett@fiddle.dee.de&quot;);
    $msg-&gt;add(Subject =&gt; &quot;A gzipp'ed tar file&quot;);  
</PRE>
</DL>



<P><HR>
<A NAME="Setting_getting_headers_and_attributes"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Setting/getting headers and attributes</H3></A>



<DL>
<P><DT><B><A NAME="item:add_TAG_VALUE">add TAG,VALUE</A></B></DT>
<DD>
Add field TAG with the given VALUE to the end of the header. 
The TAG will be converted to all-lowercase, and the VALUE 
will be made &quot;safe&quot; (returns will be given a trailing space).


<P><B>Beware:</B> any MIME fields you &quot;add&quot; will override any MIME
attributes I have when it comes time to output those fields.
Normally, you will use this method to add <I>non-MIME</I> fields:

<PRE>
    $msg-&gt;add(&quot;Subject&quot; =&gt; &quot;Hi there!&quot;);
</PRE>

<P>Giving VALUE an arrayref will cause all those values to be added:

<PRE>
    $msg-&gt;add(&quot;Received&quot; =&gt; [&quot;here&quot;, &quot;there&quot;, &quot;everywhere&quot;]
</PRE>

<P><I>Note:</I> add() is probably going to be more efficient than <CODE>replace()</CODE>,
so you're better off using it for most applications.


<P><I>Note:</I> the name comes from Mail::Header.

<P><DT><B><A NAME="item:attr_ATTR_VALUE">attr ATTR,[VALUE]</A></B></DT>
<DD>
Set MIME attribute ATTR to the string VALUE.  
ATTR is converted to all-lowercase.
This method is normally used to set/get MIME attributes:

<PRE>
    $msg-&gt;attr(&quot;content-type&quot;         =&gt; &quot;text/html&quot;);
    $msg-&gt;attr(&quot;content-type.charset&quot; =&gt; &quot;US-ASCII&quot;);
    $msg-&gt;attr(&quot;content-type.name&quot;    =&gt; &quot;homepage.html&quot;);
</PRE>

<P>This would cause the final output to look something like this:

<PRE>
    Content-type: text/html; charset=US-ASCII; name=&quot;homepage.html&quot;
</PRE>

<P>Note that the special empty sub-field tag indicates the anonymous 
first sub-field.


<P>Giving VALUE as undefined will cause the contents of the named
subfield to be deleted.


<P>Supplying no VALUE argument just returns the attribute's value:

<PRE>
    $type = $msg-&gt;attr(&quot;content-type&quot;);        # returns &quot;text/html&quot;
    $name = $msg-&gt;attr(&quot;content-type.name&quot;);   # returns &quot;homepage.html&quot;
</PRE>
<P><DT><B><A NAME="item:delete_TAG">delete TAG</A></B></DT>
<DD>
Delete field TAG with the given VALUE to the end of the header.  
The TAG will be converted to all-lowercase.

<PRE>
    $msg-&gt;delete(&quot;Subject&quot;);
</PRE>

<P><I>Note:</I> the name comes from Mail::Header.

<P><DT><B><A NAME="item:fields">fields</A></B></DT>
<DD>
Return the full header for the object, as a ref to an array
of <CODE>[TAG, VALUE]</CODE> pairs.


<P>Any fields that the user has explicitly set will override the
corresponding MIME fields that we would generate.  So: <I>don't</I> say:

<PRE>
    $msg-&gt;set(&quot;Content-type&quot; =&gt; &quot;text/html; charset=US-ASCII&quot;);
</PRE>

<P>unless you <I>mean it</I>!


<P><I>Note:</I> I called this &quot;fields&quot; because the header() method of
Mail::Header returns something different, but similar enough to 
be confusing.

<P><DT><B><A NAME="item:filename_FILENAME">filename [FILENAME]</A></B></DT>
<DD>
Set the filename which this data will be reported as.
This actually sets both &quot;standard&quot; attributes.


<P>With no argument, returns the filename as dictated by the 
content-disposition.

<P><DT><B><A NAME="item:get_TAG_INDEX">get TAG,[INDEX]</A></B></DT>
<DD>
Get the contents of field TAG, which might have been set 
with set() or replace().  Returns the text of the field.

<PRE>
    $ml-&gt;get('Subject', 0);
</PRE>

<P>If the optional 0-based INDEX is given, then we return the INDEX'th
occurence of field TAG.  Otherwise, we look at the context:
In a scalar context, only the first (0th) occurence of the 
field is returned; in an array context, <I>all</I> occurences are returned.  


<P><I>Warning:</I> this should only be used with non-MIME fields.
Behavior with MIME fields is TBD, and will raise an exception for now.

<P><DT><B><A NAME="item:get_length">get_length</A></B></DT>
<DD>
Recompute the content length for the message <I>if the process is trivial</I>, 
setting the &quot;content-length&quot; attribute as a side-effect:

<PRE>
    $msg-&gt;get_length;
</PRE>

<P>Returns the length, or undefined if not set.


<P><I>Note:</I> the content length can be difficult to compute, since it 
involves assembling the entire encoded body and taking the length
of it (which, in the case of multipart messages, means freezing
all the sub-parts, etc.).  


<P>This method only sets the content length to a defined value if the
message is a singlepart with <CODE>&quot;binary&quot;</CODE> encoding, <I>and</I> the body is
available either in-core or as a simple file.  Otherwise, the content
length is set to the undefined value.


<P>Since content-length is not a standard MIME field anyway (that's right, kids:
it's not in the MIME RFCs, it's an HTTP thing), this seems pretty fair.

<P><DT><B><A NAME="item:replace_TAG_VALUE">replace TAG,VALUE</A></B></DT>
<DD>
Delete all occurences of fields named TAG, and add a new
field with the given VALUE.  TAG is converted to all-lowercase.


<P><B>Beware:</B> any MIME fields you &quot;replace&quot; will override any MIME
attributes I have when it comes time to output those fields.
Normally, you will use this method to set <I>non-MIME</I> fields:

<PRE>
    $msg-&gt;replace(&quot;Subject&quot; =&gt; &quot;Hi there!&quot;);
</PRE>

<P>Giving VALUE as undefined will simply cause the contents of the named
field to be deleted.  Giving VALUE as an arrayref will cause all the values
in the array to be added.


<P><I>Note:</I> the name comes from Mail::Header.

</DL>



<P><HR>
<A NAME="Setting_getting_message_data"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Setting/getting message data</H3></A>



<DL>
<P><DT><B><A NAME="item:binmode_OVERRIDE">binmode [OVERRIDE]</A></B></DT>
<DD>
With no argument, returns whether or not it thinks that the data 
(as given by the &quot;Path&quot; argument of <CODE>build()</CODE>) should be read using 
binmode() (for example, when <CODE>read_now()</CODE> is invoked).


<P>The default behavior is that any content type other than 
<CODE>text/*</CODE> or <CODE>message/*</CODE> is binmode'd; this should in general work fine.


<P>With a defined argument, this method sets an explicit &quot;override&quot;
value.  An undefined argument unsets the override.
The new current value is returned.

<P><DT><B><A NAME="item:data_DATA">data [DATA]</A></B></DT>
<DD>
Get/set the literal DATA of the message.  The DATA may be
either a scalar, or a reference to an array of scalars (which
will simply be joined).    


<P><I>Warning:</I> setting the data causes the &quot;content-length&quot; attribute
to be recomputed (possibly to nothing).

<P><DT><B><A NAME="item:path_PATH">path [PATH]</A></B></DT>
<DD>
Get/set the PATH to the message data.


<P><I>Warning:</I> setting the path recomputes any existing &quot;content-length&quot; field,
and re-sets the &quot;filename&quot; (to the last element of the path if it
looks like a simple path, and to nothing if not).

<P><DT><B><A NAME="item:fh_FILEHANDLE">fh [FILEHANDLE]</A></B></DT>
<DD>
Get/set the FILEHANDLE which contains the message data.


<P>Takes a filehandle as an input and stores it in the object.
This routine is similar to path(); one important difference is that 
no attempt is made to set the content length.  

<P><DT><B><A NAME="item:resetfh_FILEHANDLE">resetfh [FILEHANDLE]</A></B></DT>
<DD>
Set the current position of the filehandle back to the beginning. 
Only applies if you used &quot;FH&quot; in build() or attach() for this message.


<P>Returns false if unable to reset the filehandle (since not all filehandles
are seekable).

<P><DT><B><A NAME="item:read_now">read_now</A></B></DT>
<DD>
Forces data from the path/filehandle (as specified by <CODE>build()</CODE>)
to be read into core immediately, just as though you had given it
literally with the <CODE>Data</CODE> keyword.  


<P>Note that the in-core data will always be used if available.


<P>Be aware that everything is slurped into a giant scalar: you may not want 
to use this if sending tar files!  The benefit of <I>not</I> reading in the data 
is that very large files can be handled by this module if left on disk
until the message is output via <CODE>print()</CODE> or <CODE>print_body()</CODE>.

<P><DT><B><A NAME="item:sign_PARAMHASH">sign PARAMHASH</A></B></DT>
<DD>
Sign the message.  This forces the message to be read into core,
after which the signature is appended to it.



<DL>
<P><DT><B><A NAME="item:Data">Data</A></B></DT>
<DD>
As in <CODE>build()</CODE>: the literal signature data.
Can be either a scalar or a ref to an array of scalars.

<P><DT><B><A NAME="item:Path">Path</A></B></DT>
<DD>
As in <CODE>build()</CODE>: the path to the file.

</DL>


<P>If no arguments are given, the default is:

<PRE>
    Path =&gt; &quot;$ENV{HOME}/.signature&quot;
</PRE>

<P>The content-length is recomputed.

</DL>



<P><HR>
<A NAME="Output"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Output</H3></A>



<DL>
<P><DT><B><A NAME="item:print_OUTHANDLE">print [OUTHANDLE]</A></B></DT>
<DD>
<I>Instance method.</I> 
Print the message to the given output handle, or to the currently-selected
filehandle if none was given.


<P>All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.

<P><DT><B><A NAME="item:print_body_OUTHANDLE">print_body [OUTHANDLE]</A></B></DT>
<DD>
<I>Instance method.</I> 
Print the body of the message to the given output handle, 
or to the currently-selected filehandle if none was given.


<P>All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.


<P><B>Fatal exception</B> raised if unable to open any of the input files,
or if a part contains no data, or if an unsupported encoding is 
encountered.

<P><DT><B><A NAME="item:print_header_OUTHANDLE">print_header [OUTHANDLE]</A></B></DT>
<DD>
<I>Instance method.</I> 
Print the header of the message to the given output handle, 
or to the currently-selected filehandle if none was given.


<P>All OUTHANDLE has to be is a filehandle (possibly a glob ref), or 
any object that responds to a print() message.

<P><DT><B><A NAME="item:as_string">as_string</A></B></DT>
<DD>
<I>Instance method.</I> 
Return the entire message as a string, with a header and an encoded body.

<P><DT><B><A NAME="item:body_as_string">body_as_string</A></B></DT>
<DD>
<I>Instance method.</I> 
Return the encoded body as a string.


<P><I>Note:</I> actually prepares the body by &quot;printing&quot; to a scalar.
Proof that you can hand the <CODE>print*()</CODE> methods any blessed object 
that responds to a <CODE>print()</CODE> message.

<P><DT><B><A NAME="item:header_as_string">header_as_string</A></B></DT>
<DD>
<I>Instance method.</I> 
Return the header as a string.

</DL>



<P><HR>
<A NAME="Sending"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Sending</H3></A>



<DL>
<P><DT><B><A NAME="item:send">send</A></B></DT>
<DD>
<P><DT><B><A NAME="item:send_HOW_HOWARGS">send HOW, HOWARGS...</A></B></DT>
<DD>
<I>Class/instance method.</I>  
This is the principle method for sending mail, and for configuring
how mail will be sent.


<P><I>As an instance method</I> (with no arguments), sends the message by whatever 
means has been set up (the default is to use the Unix &quot;sendmail&quot; program).
Returns whatever the mail-handling routine returns: this should be true 
on success, false/exception on error:

<PRE>
    $msg = MIME::Lite-&gt;new(From=&gt;...);
    $msg-&gt;send || die &quot;you DON'T have mail!&quot;;
</PRE>

<P><I>As a class method</I> (with a HOW argument and optional HOWARGS), sets up 
how the instance method will work for all objects until further notice.
It treats HOW as a facility name, with optional HOWARGS handled by
the facility.   There are three facilities:



<DL>
<P><DT><B><A NAME="item:sendmail_SENDMAILCMD">&quot;sendmail&quot;, SENDMAILCMD</A></B></DT>
<DD>
Send a message by piping it into the &quot;sendmail&quot; command.
Uses the <CODE>send_by_sendmail()</CODE> method, giving it the SENDMAILCMD.
This usage implements (and deprecates) the <CODE>sendmail()</CODE> method.
 
=item &quot;smtp&quot;, [HOSTNAME]


<P>Send a message by SMTP, using optional HOSTNAME as SMTP-sending host.
Uses the <CODE>send_by_smtp()</CODE> method.

<P><DT><B><A NAME="item:sub_SUBREF_ARGS">&quot;sub&quot;, \&amp;SUBREF, ARGS...</A></B></DT>
<DD>
Sends a message MSG by invoking the subroutine SUBREF of your choosing,
with MSG as the first argument, and ARGS following.

</DL>


<P><I>For example:</I> let's say you're on an OS which lacks the usual Unix
&quot;sendmail&quot; facility, but you've installed something a lot like it, and
you need to configure your Perl script to use this &quot;sendmail.exe&quot; program.
Do this following in your script's setup:

<PRE>
    MIME::Lite-&gt;send('sendmail', &quot;d:\\programs\\sendmail.exe&quot;);
</PRE>

<P>Then, whenever you need to send a message $msg, just say:

<PRE>
    $msg-&gt;send;
</PRE>

<P>That's it.  Now, if you ever move your script to a Unix box, all you
need to do is change that line in the setup and you're done.
All of your $msg-&gt;send invocations will work as expected.

<P><DT><B><A NAME="item:send_by_sendmail_SENDMAILCMD">send_by_sendmail SENDMAILCMD</A></B></DT>
<DD>
<I>Instance method.</I>
Send message via the external &quot;sendmail&quot; program, SENDMAILCMD.
Returns true on success, false or exception on error.


<P><I>Note:</I> this facility will probably only work on Unix systems.
The SENDMAILCMD for this facility must get all its message-specific 
information from the standard input.

<P><DT><B><A NAME="item:send_by_smtp_ARGS">send_by_smtp [ARGS...]</A></B></DT>
<DD>
<I>Instance method.</I>
Send message via SMTP, using Net::SMTP.  
The ARGS are sent into Net::SMTP::new(): usually, these are

<PRE>
    MAILHOST, OPTION=&gt;VALUE, ...
</PRE>

<P>Note that the list of recipients is taken from the 
&quot;To&quot;, &quot;Cc&quot; and &quot;Bcc&quot; fields.


<P>Returns true on success, false or exception on error.

<P><DT><B><A NAME="item:sendmail_COMMAND">sendmail COMMAND...</A></B></DT>
<DD>
<I>Class method, DEPRECATED.</I>  
Declare the sender to be &quot;sendmail&quot;, and set up the &quot;sendmail&quot; command.
<I>You should use send() instead.</I>

</DL>



<P><HR>
<A NAME="Miscellaneous"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Miscellaneous</H3></A>



<DL>
<P><DT><B><A NAME="item:quiet_ONOFF">quiet ONOFF</A></B></DT>
<DD>
<I>Class method.</I>  
Suppress/unsuppress all warnings coming from this module.

<PRE>
    quiet MIME::Lite 1;       # I know what I'm doing
</PRE>

<P>I recommend that you include that comment as well.  And while
you type it, say it out loud: if it doesn't feel right, then maybe
you should reconsider the whole line.  <CODE>;-)</CODE>

</DL>



<P><HR>
<A NAME="NOTES"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NOTES</H2></A>



<P><HR>
<A NAME="Limitations"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Limitations</H3></A>


<P>This is &quot;lite&quot;, after all...



<UL>
<P><LI>
<P>There's no parsing.  Get MIME-tools if you need to parse MIME messages.

<P><LI>
<P>MIME::Lite messages are currently <I>not</I> interchangeable with 
either Mail::Internet or MIME::Entity objects.  This is a completely 
separate module.

<P><LI>
<P>A content-length field is only inserted if the encoding is binary,
the message is a singlepart, and all the document data is available
at <CODE>build()</CODE> time by virtue of residing in a simple path, or in-core.
Since content-length is not a standard MIME field anyway (that's right, kids:
it's not in the MIME RFCs, it's an HTTP thing), this seems pretty fair.

<P><LI>
<P>MIME::Lite alone cannot help you lose weight.  You must supplement
your use of MIME::Lite with a healthy diet and exercise. 

</UL>



<P><HR>
<A NAME="Cheap_and_easy_mailing"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Cheap and easy mailing</H3></A>


<P>I thought putting in a default &quot;sendmail&quot; invocation wasn't too bad an 
idea, since a lot of Perlers are on UNIX systems.  The default arguments
to sendmail (which you can change) are:

<PRE>
     -t      Scan message for To:, Cc:, Bcc:, etc.
              
     -oi     Do NOT treat a single &quot;.&quot; on a line as a message terminator.
             As in, &quot;-oi vey, it truncated my message... why?!&quot;
                
     -oem    On error, mail back the message (I assume to the
             appropriate address, given in the header).
             When mail returns, circle is complete.  Jai guru deva -oem.
</PRE>

<P>If you're not on a Unix system, or if you'd just rather send mail
some other way, check out the <CODE>send()</CODE> method.  There's built in
support for SMTP delivery, or you can slip in your own hooks. 



<P><HR>
<A NAME="Under_the_hood"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Under the hood</H3></A>


<P>This class treats a MIME header in the most abstract sense,
as being a collection of high-level attributes.  The actual
RFC-822-style header fields are not constructed until it's time
to actually print the darn thing.



<P><HR>
<A NAME="WARNINGS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> WARNINGS</H2></A>



<P><HR>
<A NAME="MIME-_and_non-MIME_header_fields"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> MIME- and non-MIME header fields</H3></A>


<P><B>Important:</B> the MIME attributes are stored and manipulated separately 
from the message header fields; when it comes time to print the 
header out, <I>any explicitly-given header fields override the ones that
would be created from the MIME attributes.</I>  That means that this:

<PRE>
    ### DANGER ### DANGER ### DANGER ### DANGER ### DANGER ###
    $msg-&gt;add(&quot;Content-type&quot;, &quot;text/html; charset=US-ASCII&quot;);
</PRE>

<P>will set the exact <CODE>&quot;Content-type&quot;</CODE> field in the header I write, 
<I>regardless of what the actual MIME attributes are.</I>


<P><I>This feature is for experienced users only,</I> as an escape hatch in case
the code that normally formats MIME header fields isn't doing what 
you need.  And, like any escape hatch, it's got an alarm on it:
MIME::Lite will warn you if you attempt to <CODE>set()</CODE> or <CODE>replace()</CODE>
any MIME header field.  Use <CODE>attr()</CODE> instead.



<P><HR>
<A NAME="Lines_consisting_of_a_single_dot"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Lines consisting of a single dot</H3></A>


<P>Julian Haight noted that MIME::Lite allows you to compose messages
with lines in the body consisting of a single &quot;.&quot;.  
This is true: it should be completely harmless so long as &quot;sendmail&quot; 
is used with the -oi option (see <A HREF="#Cheap_and_easy_mailing">Cheap and easy mailing</A>).


<P>However, I don't know if using Net::SMTP to transfer such a message
is equally safe.  Feedback is welcomed.


<P>My perspective: I don't want to magically diddle with a user's 
message unless absolutely positively necessary.  
Some users may want to send files with &quot;.&quot; alone on a line;
my well-meaning tinkering could seriously harm them.



<P><HR>
<A NAME="A_MIME_PRIMER"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> A MIME PRIMER</H2></A>



<P><HR>
<A NAME="Content_types"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Content types</H3></A>


<P>The &quot;Type&quot; parameter of <CODE>build()</CODE> is a <I>content type</I>. 
This is the actual type of data you are sending.  
Generally this is a string of the form <CODE>&quot;majortype/minortype&quot;</CODE>.


<P>Here are the major MIME types.
A more-comprehensive listing may be found in RFC-2046.



<DL>
<P><DT><B><A NAME="item:application">application</A></B></DT>
<DD>
Data which does not fit in any of the other categories, particularly 
data to be processed by some type of application program. 
<CODE>application/octet-stream</CODE>, <CODE>application/gzip</CODE>, <CODE>application/postscript</CODE>...

<P><DT><B><A NAME="item:audio">audio</A></B></DT>
<DD>
Audio data.
<CODE>audio/basic</CODE>...

<P><DT><B><A NAME="item:image">image</A></B></DT>
<DD>
Graphics data.
<CODE>image/gif</CODE>, <CODE>image/jpeg</CODE>...

<P><DT><B><A NAME="item:message">message</A></B></DT>
<DD>
A message, usually another mail or MIME message.
<CODE>message/rfc822</CODE>...

<P><DT><B><A NAME="item:multipart">multipart</A></B></DT>
<DD>
A message containing other messages.
<CODE>multipart/mixed</CODE>, <CODE>multipart/alternative</CODE>...

<P><DT><B><A NAME="item:text">text</A></B></DT>
<DD>
Textual data, meant for humans to read.
<CODE>text/plain</CODE>, <CODE>text/html</CODE>...

<P><DT><B><A NAME="item:video">video</A></B></DT>
<DD>
Video or video+audio data.
<CODE>video/mpeg</CODE>...

</DL>



<P><HR>
<A NAME="Content_transfer_encodings"><H3><A HREF="#__TOP__"><IMG SRC="icons/h2bullet.gif" ALT="Top" BORDER="0"></A> Content transfer encodings</H3></A>


<P>The &quot;Encoding&quot; parameter of <CODE>build()</CODE>.
This is how the message body is packaged up for safe transit.


<P>Here are the 5 major MIME encodings.
A more-comprehensive listing may be found in RFC-2045.



<DL>
<P><DT><B><A NAME="item:7bit">7bit</A></B></DT>
<DD>
Basically, no <I>real</I> encoding is done.  However, this label guarantees that no
8-bit characters are present, and that lines do not exceed 1000 characters 
in length.

<P><DT><B><A NAME="item:8bit">8bit</A></B></DT>
<DD>
Basically, no <I>real</I> encoding is done.  The message might contain 8-bit 
characters, but this encoding guarantees that lines do not exceed 1000 
characters in length.

<P><DT><B><A NAME="item:binary">binary</A></B></DT>
<DD>
No encoding is done at all.  Message might contain 8-bit characters,
and lines might be longer than 1000 characters long.


<P>The most liberal, and the least likely to get through mail gateways.  
Use sparingly, or (better yet) not at all.

<P><DT><B><A NAME="item:base64">base64</A></B></DT>
<DD>
Like &quot;uuencode&quot;, but very well-defined.  This is how you should send
essentially binary information (tar files, GIFs, JPEGs, etc.). 

<P><DT><B><A NAME="item:quoted-printable">quoted-printable</A></B></DT>
<DD>
Useful for encoding messages which are textual in nature, yet which contain 
non-ASCII characters (e.g., Latin-1, Latin-2, or any other 8-bit alphabet).

</DL>



<P><HR>
<A NAME="CHANGE_LOG"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> CHANGE LOG</H2></A>


<P><B>Current version:</B>
$Id: Lite.pm,v 1.137 2000/03/22 07:21:02 eryq Exp $



<DL>
<P><DT><B><A NAME="item:Version_1_137">Version 1.137</A></B></DT>
<DD>
Per popular request, added support for &quot;Cc&quot; and &quot;Bcc&quot; in send_by_smtp().
To turn this off, set $MIME::Lite::AUTO_CC to false.


<P>Chooses a better default content-transfer-encoding if the content-type
is &quot;image/*&quot;, &quot;audio/*&quot;, etc.
To tuern this off, set $MIME::Lite::AUTO_ENCODE to false.


<P>Fixed bug in QP-encoding where a non-local <CODE>$_</CODE> was being modified.


<P>Removed references to <CODE>$`</CODE>, <CODE>$'</CODE>, and <CODE>$&amp;</CODE>.

<P><DT><B><A NAME="item:Version_1_133">Version 1.133</A></B></DT>
<DD>
Fixed bug in &quot;Data&quot; handling: arrayrefs were not being handled
properly.

<P><DT><B><A NAME="item:Version_1_130">Version 1.130</A></B></DT>
<DD>
Added much larger and more-flexible send() facility.
<I>Thanks to Andrew McRae (and Optimation New Zealand Ltd) 
for the Net::SMTP interface.  Additional thanks to the many folks
who requested this feature.</I>


<P>Added get() method for extracting basic attributes.


<P>New... &quot;t&quot; tests!

<P><DT><B><A NAME="item:Version_1_124">Version 1.124</A></B></DT>
<DD>
Folded in filehandle (FH) support in build/attach.
<I>Thanks to Miko O'Sullivan for the code.</I>

<P><DT><B><A NAME="item:Version_1_122">Version 1.122</A></B></DT>
<DD>
MIME::Base64 and MIME::QuotedPrint are used if available.


<P>The 7bit encoding no longer does &quot;escapes&quot;; it merely strips 8-bit characters.

<P><DT><B><A NAME="item:Version_1_121">Version 1.121</A></B></DT>
<DD>
Filename attribute is now no longer ignored by build().
<I>Thanks to Ian Smith for finding and patching this bug.</I>

<P><DT><B><A NAME="item:Version_1_120">Version 1.120</A></B></DT>
<DD>
Efficiency hack to speed up MIME::Lite::IO_Scalar.
<I>Thanks to David Aspinwall for the patch.</I>

<P><DT><B><A NAME="item:Version_1_116">Version 1.116</A></B></DT>
<DD>
Small bug in our private copy of encode_base64() was patched.
<I>Thanks to Andreas Koenig for pointing this out.</I>


<P>New, prettier way of specifying mail message headers in <CODE>build()</CODE>.


<P>New quiet method to turn off warnings.


<P>Changed &quot;stringify&quot; methods to more-standard &quot;as_string&quot; methods.

<P><DT><B><A NAME="item:Version_1_112">Version 1.112</A></B></DT>
<DD>
Added <CODE>read_now()</CODE>, and <CODE>binmode()</CODE> method for our non-Unix-using brethren: 
file data is now read using binmode() if appropriate.
<I>Thanks to Xiangzhou Wang for pointing out this bug.</I>

<P><DT><B><A NAME="item:Version_1_110">Version 1.110</A></B></DT>
<DD>
Fixed bug in opening the data filehandle.

<P><DT><B><A NAME="item:Version_1_102">Version 1.102</A></B></DT>
<DD>
Initial release.

<P><DT><B><A NAME="item:Version_1_101">Version 1.101</A></B></DT>
<DD>
Baseline code.

</DL>



<P><HR>
<A NAME="TERMS_AND_CONDITIONS"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> TERMS AND CONDITIONS</H2></A>


<P>Copyright (c) 1997 by Eryq.  
Copyright (c) 1998 by ZeeGee Software Inc.
All rights reserved.  This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.  


<P>This software comes with <B>NO WARRANTY</B> of any kind.
See the COPYING file in the distribution for details.



<P><HR>
<A NAME="NUTRITIONAL_INFORMATION"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> NUTRITIONAL INFORMATION</H2></A>


<P>For some reason, the US FDA says that this is now required by law
on any products that bear the name &quot;Lite&quot;...

<PRE>
    Serving size:             1 module
    Servings per container:   1
    Calories:                 0
    Fat:                      0g
      Saturated Fat:          0g
</PRE>
<PRE>
    Warning: for consumption by hardware only!  May produce 
    indigestion in humans if taken internally.
</PRE>


<P><HR>
<A NAME="AUTHOR"><H2><A HREF="#__TOP__"><IMG SRC="icons/h1bullet.gif" ALT="Top" BORDER="0"></A> AUTHOR</H2></A>


<P>Eryq (<I><FILE><A HREF="mailto:eryq@zeegee.com">eryq@zeegee.com</A></FILE></I>).
President, ZeeGee Software Inc. (<I><FILE><A HREF="http://www.zeegee.com">http://www.zeegee.com</A></FILE></I>).


<P>Created: 11 December 1996.  Ho ho ho.

<P><HR>
<ADDRESS><FONT SIZE=-1>
Generated Thu Mar 23 01:54:30 2000 by cvu_pod2html
</FONT></ADDRESS>
</BODY>
</HTML>
